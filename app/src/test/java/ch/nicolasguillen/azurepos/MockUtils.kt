@file:Suppress("unused", "UNUSED_PARAMETER")

package ch.nicolasguillen.azurepos

import io.reactivex.observers.TestObserver
import org.mockito.ArgumentCaptor
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.stubbing.OngoingStubbing
import org.mockito.stubbing.Stubber
import kotlin.reflect.KClass

fun <T> Stubber.whenever(mock: T): T = `when`(mock)
fun <T> whenever(methodCall: T): OngoingStubbing<T> = `when`(methodCall)

fun <T> any(): T {
    Mockito.any<T>()
    return uninitialized()
}

fun <T> TestObserver<T>.onNextEvents(): List<Any> = events[0]
fun <T> TestObserver<T>.onErrorEvents(): List<Any> = events[1]

@Suppress("UNCHECKED_CAST")
private fun <T> uninitialized(): T = null as T

fun <T : Any> createInstance(kClass: KClass<T>): T {
    return castNull()
}

/**
 * Uses a quirk in the bytecode generated by Kotlin
 * to cast null to a non-null type.
 *
 * See https://youtrack.jetbrains.com/issue/KT-8135.
 */
@Suppress("UNCHECKED_CAST")
private fun <T> castNull(): T = null as T

inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java), T::class)
}

class KArgumentCaptor<out T : Any?>(
        private val captor: ArgumentCaptor<T>,
        private val tClass: KClass<*>
) {

    /**
     * The first captured value of the argument.
     * @throws IndexOutOfBoundsException if the value is not available.
     */
    val firstValue: T
        get() = captor.firstValue

    /**
     * The second captured value of the argument.
     * @throws IndexOutOfBoundsException if the value is not available.
     */
    val secondValue: T
        get() = captor.secondValue

    /**
     * The third captured value of the argument.
     * @throws IndexOutOfBoundsException if the value is not available.
     */
    val thirdValue: T
        get() = captor.thirdValue

    /**
     * The last captured value of the argument.
     * @throws IndexOutOfBoundsException if the value is not available.
     */
    val lastValue: T
        get() = captor.lastValue

    val allValues: List<T>
        get() = captor.allValues

    @Suppress("UNCHECKED_CAST")
    fun capture(): T {
        return captor.capture() ?: createInstance(tClass) as T
    }
}

val <T> ArgumentCaptor<T>.firstValue: T
    get() = allValues[0]

val <T> ArgumentCaptor<T>.secondValue: T
    get() = allValues[1]

val <T> ArgumentCaptor<T>.thirdValue: T
    get() = allValues[2]

val <T> ArgumentCaptor<T>.lastValue: T
    get() = allValues.last()